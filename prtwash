#!/bin/bash
#
#    prtwash - a simple bash script for cleaning the port tree
#              of the CRUX Linux distribution.
#
#    Copyright (c) 2003 by Simone Rota                  <sip@varlock.com>
#
#    *************************************************************************
#    *                                                                       *
#    * This program is free software; you can redistribute it and/or modify  *
#    * it under the terms of the GNU General Public License as published by  *
#    * the Free Software Foundation; either version 2 of the License, or     *
#    * (at your option) any later version.                                   *
#    *                                                                       *
#    *************************************************************************
#
#   Took some inspiration and code from Martin Opel's prtsweep v1.6 script
#
#   **** USE AT YOUR OWN RISK ****
#
#   TODO  
#         - a summary of files / bytes removed after the
#           execution would be useful.
#

VERSION="0.8"
CONFIGFILE="/etc/prt-get.conf"

usage() {
    echo "Usage: prtwash [-p] [-s] [-d] [-t] [-a] <path> [<path> ...]"
    exit 1
}

showversion() {
    echo "prtwash" $VERSION
    echo "(c) 2003 by Simone Rota"
    echo "This program is distributed under the GNU GPL license"
}

interrupted() {
    echo "=======> operation interrupted."
    exit 1
}

checkparams() {
# Do some test on given parameters.
    if [ "$auto" = "0" ]; then

        if [ -z "$prtdirs" ]; then
            usage
            exit -1
        fi

        for (( p=0 ; p<=${#prtdirs[@]} ; p++ )); do
        
            if [ -z "${prtdirs[$p]}" ]; then
                unset prtdirs[$p]
                continue
            fi
            
            if [ ! -d "${prtdirs[$p]}" ]; then
                echo "WARN: directory '${prtdirs[$p]}' not found. Skipping."
                unset prtdirs[$p]
                continue
            fi

            if [ ! -f "${prtdirs[$p]}"/Pkgfile ]; then
                echo "WARN: no Pkgfile found in '${prtdirs[$p]}'. Skipping."
                unset prtdirs[$p]
            fi
        done
    fi
}

getoptions () {
# Name says it all.
    while getopts psdathv opt; do
        case "$opt" in
            p) removepackage=1;;
            s) removesources=1;;
            d) removeaddonfiles=1;;
            t) test=1;;
            a) auto=1;;
            h) usage
                exit 0
                ;;
            v) showversion
                exit 0
                ;;
            \?) usage
                exit -1
                ;;
        esac
    done
    shift $(($OPTIND - 1))
    prtdirs=("$@")
}

getdirs() {
# scans /etc/prt-get.conf for port dirs to process
    current=""
    for s in `sed 's/^[ \t]*//;s/[ \t]*$//' \
             $CONFIGFILE|grep '^prtdir.*:'|sed 's/:/ /;s/,/ /;s/prtdir//;s/#.*//'`
    do
        if [ "`echo $s|grep '/'`" != "" ]; then
            current=$s
        else
            if [ "$current" != "" ]; then
                singledirs=(${singledirs[*]} $current/$s)
            fi    
        fi
    done

    for s in `sed 's/^[ \t]*//;s/[ \t]*$//;/:/d' \
             $CONFIGFILE|grep '^prtdir.*'|sed 's/prtdir//;s/#.*//'`
    do
        basedirs=(${basedirs[*]} $s)
    done

}


remove() {
# Removes a file/directory
    if [ "$test" = 1 ]; then
        echo "+ (t) removing" $1
    else
        echo "+ removing" $1
        rm -r $1
    fi
}

wash() {
# Does the actual removal work.
    if [ ! -f "$1"/Pkgfile ]; then
    # tested before, the test here is for
    # auto (-a) command
        echo "WARN: no Pkgfile found in $1. Skipping."
    else
        tosave=() # array of files not to be deleted
        . "$1"/Pkgfile
        PKGMK_COMPRESSION_MODE="gz"
        [ -f /etc/pkgmk.conf ] && . /etc/pkgmk.conf
        packagename="$name"#"$version"-"$release"".pkg.tar.$PKGMK_COMPRESSION_MODE"

        if [ ! "$removesources" = 1 ]; then
        # keep sources
            for src in "${source[@]}"; do 
                tosave=( "${tosave[@]}" "`basename "$src"`" )
            done
        fi

        if [ ! "$removepackage" = 1 ]; then
        # keep package
               tosave=( "${tosave[@]}" "$packagename" )
        fi

        if [ ! "$removeaddonfiles" = 1 ]; then
        # keep additional and dot files
            tosave=( "${tosave[@]}" ".signature" )
            tosave=( "${tosave[@]}" ".32bit" )
            tosave=( "${tosave[@]}" ".footprint" )
            tosave=( "${tosave[@]}" ".nostrip" )
            tosave=( "${tosave[@]}" "README" )
            tosave=( "${tosave[@]}" "FAQ" )
            tosave=( "${tosave[@]}" "pre-install" )
            tosave=( "${tosave[@]}" "post-install" )
        fi

        # keep Pkgfile. We always want to keep this nice funny file.
        tosave=( "${tosave[@]}" "Pkgfile" )

          # new in version 0.3 we (try to) always save files that are
        # retrieved by cvs (non http(s) or ftp in source)
        # ie patches, etc. This can be deleted with -d (extra files)
        # option
        if [ ! "$removeaddonfiles" = 1 ]; then
            for src in "${source[@]}"; do 
                #echo $src
                if [ "${src:0:7}" != "http://" \
                     -a "${src:0:8}" != "https://" \
                     -a "${src:0:6}" != "ftp://" ]
                then
                    #echo "`basename "$src"`" "will NOT be deleted"
                    tosave=( "${tosave[@]}" "`basename "$src"`" )
                fi
            done
        fi

        for f in "$1"/{*,.footprint,.signature,.32bit}; do
            if ! keep $f; then
                remove $f
            fi  
        done
    fi
}

keep() {
# Chechs if filename item is in tosave[] array
# return 1 if present, 0 if not.
    item=$1
    for i in "${tosave[@]}"; do
        if [ "$i" = `basename "$item"` ]; then
            return 0
        fi
    done
      
    return 1
}

printparams() {
# used for testing.
    echo removepackage: $removepackage
    echo removesources: $removesources
    echo removeaddonfiles: $removeaddonfiles
    echo auto: $auto
    echo test: $test
}


###################################################
# Main
###################################################

trap "interrupted" SIGHUP SIGINT SIGQUIT SIGTERM

if [ $# -lt 1 ]; then
    usage
    exit -1
fi


removepackage=0
removesources=0
removeaddonfiles=0
test=0
auto=0
basedirs=()
singledirs=()
prtdirs=()


getoptions $@
checkparams $@


if [ "$auto" = 0 ]; then

    for p in ${prtdirs[@]}; do
        wash $p
    done

else

    if [ ! -f "$CONFIGFILE" ]; then
        echo "ERROR: cannot find configuration file '$CONFIGFILE'"
        exit -1
    fi
    echo "Analyzing port tree..."

    getdirs
    
    # wash base dirs
    for d in ${basedirs[*]}; do
        if [ -d "$d" ]; then
            for p in "$d"/*; do
                if [ -d "$p" ]; then
                    wash $p
                fi  
            done
        else
            echo "ERROR: directory '$d' not found, check your configuration file!" 
        fi 
    done 

    # wash custom dirs (see prt-get.conf)
    for p in ${singledirs[*]}; do
         if [ -d "$p" ]; then
             wash $p
         else
             echo "ERROR: directory '$p' not found, check your configuration file!"
         fi      
    done
fi

exit 0
